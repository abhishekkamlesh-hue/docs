---
title: "Recording Status Webhook"
api: "POST /callRecordingStatus"
description: "Notified when call recording is ready for download"
---

## üìº Overview

When a call recording is completed and processed, Plivo/dialer sends this webhook with the recording URL. VoiceGenie downloads it, stores in S3, triggers transcription, and updates the call record.

---

##  Authentication

<ParamField header="X-Plivo-Signature-V2" type="string" required>
  HMAC SHA256 signature for webhook verification
</ParamField>

---

##  Request Body

<ParamField body="CallUUID" type="string" required>
  Unique call identifier
  ```
  call-uuid-abc123
  ```
</ParamField>

<ParamField body="RecordingUrl" type="string" required>
  Direct URL to download recording file
  ```
  https://s3.plivo.com/recordings/MAXXXXXX/abc123.mp3
  ```
</ParamField>

<ParamField body="RecordingID" type="string" required>
  Unique recording identifier
  ```
  recording-xyz789
  ```
</ParamField>

<ParamField body="RecordingDuration" type="integer" required>
  Duration in seconds
  ```
  345
  ```
</ParamField>

<ParamField body="RecordingStartTime" type="string" required>
  ISO 8601 timestamp when recording started
  ```
  2024-01-16T10:30:15Z
  ```
</ParamField>

<ParamField body="RecordingEndTime" type="string" required>
  ISO 8601 timestamp when recording ended
  ```
  2024-01-16T10:36:00Z
  ```
</ParamField>

<ParamField body="RecordingFormat" type="string">
  Audio format (default: mp3)
  ```
  mp3
  ```
  
  **Options:** `mp3`, `wav`
</ParamField>

<ParamField body="RecordingType" type="string">
  Type of recording
  
  **Values:**
  - `call` - Full call recording
  - `voicemail` - Voicemail message
  - `conference` - Conference recording
</ParamField>

<ParamField body="From" type="string">
  Caller's phone number
</ParamField>

<ParamField body="To" type="string">
  Called phone number
</ParamField>

<ParamField body="CallStatus" type="string">
  Call status: `completed`
</ParamField>

---

##  VoiceGenie Processing Flow

```
Recording Ready ‚Üí Webhook received ‚Üí Verify signature
                                           ‚Üì
                          1. Download recording from Plivo S3
                          2. Upload to VoiceGenie S3 bucket
                          3. Update call record with URL
                          4. Trigger transcription service
                          5. Send WebSocket notification
                          6. Update campaign analytics
                                           ‚Üì
                          Return 200 OK ‚Üí Process complete
```

---

## Response

### Success (200 OK):
```json
{
  "success": true,
  "message": "Recording processed successfully",
  "data": {
    "recording_id": "recording-xyz789",
    "call_uuid": "call-abc123",
    "storage_url": "https://voicegenie-recordings.s3.amazonaws.com/abc123.mp3",
    "transcription_initiated": true
  }
}
```

### Error (400/500):
```json
{
  "success": false,
  "error": "Failed to download recording",
  "details": "Connection timeout after 30s"
}
```

---

## üíæ Storage Strategy

### 1. Download from Plivo:
```javascript
const axios = require('axios');
const fs = require('fs');

async function downloadRecording(recordingUrl) {
  const response = await axios({
    method: 'get',
    url: recordingUrl,
    responseType: 'stream',
    timeout: 60000 // 60s timeout
  });
  
  const filePath = `/tmp/${callUUID}.mp3`;
  const writer = fs.createWriteStream(filePath);
  response.data.pipe(writer);
  
  return new Promise((resolve, reject) => {
    writer.on('finish', () => resolve(filePath));
    writer.on('error', reject);
  });
}
```

### 2. Upload to S3:
```javascript
const AWS = require('aws-sdk');
const s3 = new AWS.S3();

async function uploadToS3(filePath, callUUID) {
  const fileContent = fs.readFileSync(filePath);
  
  const params = {
    Bucket: 'voicegenie-recordings',
    Key: `recordings/${new Date().getFullYear()}/${callUUID}.mp3`,
    Body: fileContent,
    ContentType: 'audio/mpeg',
    ServerSideEncryption: 'AES256',
    StorageClass: 'INTELLIGENT_TIERING',
    Metadata: {
      'call-uuid': callUUID,
      'uploaded-at': new Date().toISOString()
    }
  };
  
  const result = await s3.upload(params).promise();
  return result.Location;
}
```

### 3. Generate Presigned URL:
```javascript
function generatePresignedUrl(s3Key, expiresIn = 3600) {
  const params = {
    Bucket: 'voicegenie-recordings',
    Key: s3Key,
    Expires: expiresIn // 1 hour
  };
  
  return s3.getSignedUrl('getObject', params);
}
```

---

## üéôÔ∏è Transcription Service

After storing recording, trigger transcription:

```javascript
const { OpenAI } = require('openai');
const openai = new OpenAI();

async function transcribeRecording(audioFilePath) {
  const transcription = await openai.audio.transcriptions.create({
    file: fs.createReadStream(audioFilePath),
    model: 'whisper-1',
    language: 'en', // Auto-detect if not specified
    response_format: 'verbose_json',
    timestamp_granularities: ['word', 'segment']
  });
  
  return {
    text: transcription.text,
    duration: transcription.duration,
    segments: transcription.segments, // Timestamped segments
    words: transcription.words, // Word-level timestamps
    language: transcription.language
  };
}
```

### Transcription Output:
```json
{
  "text": "Hi, I'm interested in your premium plan. Can you tell me more about the features?",
  "duration": 8.5,
  "language": "en",
  "segments": [
    {
      "id": 0,
      "start": 0.0,
      "end": 2.5,
      "text": "Hi, I'm interested in your premium plan.",
      "confidence": 0.98
    },
    {
      "id": 1,
      "start": 2.8,
      "end": 8.5,
      "text": "Can you tell me more about the features?",
      "confidence": 0.95
    }
  ],
  "words": [
    {"word": "Hi", "start": 0.0, "end": 0.3},
    {"word": "I'm", "start": 0.35, "end": 0.5},
    {"word": "interested", "start": 0.55, "end": 1.2}
    // ... more words
  ]
}
```

---

## Post-Processing Analytics

### 1. Sentiment Analysis:
```javascript
async function analyzeSentiment(transcription) {
  const response = await openai.chat.completions.create({
    model: 'gpt-4',
    messages: [
      {
        role: 'system',
        content: 'Analyze sentiment and extract key insights from this call transcript.'
      },
      {
        role: 'user',
        content: transcription
      }
    ]
  });
  
  return {
    overall_sentiment: 'positive',
    customer_satisfaction: 8.5,
    intent: 'purchase_inquiry',
    objections: ['pricing'],
    interests: ['premium_plan', 'features'],
    outcome: 'demo_scheduled'
  };
}
```

### 2. Compliance Checks:
```javascript
function checkCompliance(transcription) {
  const issues = [];
  
  // Check for required disclosures
  if (!transcription.includes('this call may be recorded')) {
    issues.push('Missing recording disclosure');
  }
  
  // Check for prohibited content
  const prohibited = ['guaranteed', 'risk-free', 'unlimited returns'];
  prohibited.forEach(term => {
    if (transcription.toLowerCase().includes(term)) {
      issues.push(`Prohibited term used: ${term}`);
    }
  });
  
  return {
    compliant: issues.length === 0,
    issues
  };
}
```

---

## WebSocket Notification

Send real-time notification to dashboard:

```javascript
const WebSocket = require('ws');

function notifyRecordingReady(callUUID, recordingData) {
  const wsMessage = {
    event: 'recording.ready',
    data: {
      call_uuid: callUUID,
      recording_url: recordingData.url,
      duration: recordingData.duration,
      transcription_status: 'processing',
      timestamp: new Date().toISOString()
    }
  };
  
  // Send to all connected clients subscribed to this call
  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      if (client.subscribedCalls.includes(callUUID)) {
        client.send(JSON.stringify(wsMessage));
      }
    }
  });
}
```

---

## Example Use Cases

### 1. Quality Assurance Review:
```javascript
async function scoreCallQuality(transcription, recordingUrl) {
  const metrics = {
    greeting: transcription.startsWith('Hi') || transcription.startsWith('Hello'),
    introduction: transcription.includes('my name is'),
    closing: transcription.includes('have a great day') || transcription.includes('thank you'),
    clarity_score: await analyzeAudioClarity(recordingUrl),
    objection_handling: countObjectionsHandled(transcription),
    rapport_building: detectRapportPhrases(transcription)
  };
  
  const score = calculateQAScore(metrics);
  
  return {
    score, // 0-100
    metrics,
    recommendations: generateRecommendations(metrics)
  };
}
```

### 2. Training Dataset Generation:
```javascript
async function addToTrainingDataset(callUUID, transcription, outcome) {
  // Store successful calls as training examples
  if (outcome === 'sale' || outcome === 'demo_scheduled') {
    await TrainingData.create({
      call_uuid: callUUID,
      transcript: transcription,
      outcome,
      script_version: 'v2.1',
      agent_score: 9.2,
      tags: ['successful', 'high_quality']
    });
  }
}
```

---

##  Performance Optimization

### Async Processing:
```javascript
// Don't wait for transcription to complete
app.post('/callRecordingStatus', async (req, res) => {
  const { CallUUID, RecordingUrl } = req.body;
  
  // Respond immediately
  res.status(200).json({ success: true, message: 'Processing...' });
  
  // Process asynchronously
  processRecordingAsync(CallUUID, RecordingUrl).catch(err => {
    logger.error('Recording processing failed', err);
  });
});

async function processRecordingAsync(callUUID, recordingUrl) {
  const filePath = await downloadRecording(recordingUrl);
  const s3Url = await uploadToS3(filePath, callUUID);
  const transcription = await transcribeRecording(filePath);
  const sentiment = await analyzeSentiment(transcription.text);
  
  await updateCallRecord(callUUID, {
    recording_url: s3Url,
    transcription: transcription.text,
    sentiment
  });
  
  notifyRecordingReady(callUUID, { url: s3Url });
  
  // Cleanup temp file
  fs.unlinkSync(filePath);
}
```

---

## üß™ Testing

### cURL Request:
```bash
curl -X POST https://vb-seamless-dev-backend.oriserve.com/callRecordingStatus \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -H "X-Plivo-Signature-V2: YOUR_SIGNATURE" \
  -d "CallUUID=test-call-123" \
  -d "RecordingUrl=https://s3.plivo.com/recordings/test.mp3" \
  -d "RecordingID=recording-123" \
  -d "RecordingDuration=345" \
  -d "RecordingStartTime=2024-01-16T10:30:15Z" \
  -d "RecordingEndTime=2024-01-16T10:36:00Z" \
  -d "RecordingFormat=mp3"
```

### Mock Recording URL:
```javascript
// For testing, use a sample audio file
const mockRecordingUrl = 'https://file-examples.com/wp-content/uploads/2017/11/file_example_MP3_700KB.mp3';
```

---

##  Error Handling

### Download Timeout:
```javascript
try {
  const filePath = await downloadRecording(recordingUrl, { timeout: 60000 });
} catch (error) {
  if (error.code === 'ETIMEDOUT') {
    // Retry with exponential backoff
    await retryDownload(recordingUrl, maxRetries = 3);
  }
}
```

### S3 Upload Failure:
```javascript
try {
  const s3Url = await uploadToS3(filePath, callUUID);
} catch (error) {
  // Fallback to backup storage
  const backupUrl = await uploadToBackupStorage(filePath);
  logger.error('S3 upload failed, used backup', { error, backupUrl });
}
```

### Transcription Error:
```javascript
try {
  const transcription = await transcribeRecording(filePath);
} catch (error) {
  // Mark as failed, allow manual retry
  await updateCallRecord(callUUID, {
    transcription_status: 'failed',
    transcription_error: error.message
  });
}
```

---

## Rate Limits

| Plan | Max Recording Size | Transcription/month | Storage |
|------|-------------------|---------------------|---------|
| Free | 10 MB | 10 hours | 1 GB |
| Basic | 50 MB | 100 hours | 10 GB |
| Pro | 500 MB | 1000 hours | 100 GB |
| Enterprise | Unlimited | Unlimited | Unlimited |

---

## üíæ Data Retention

| Type | Retention Period | After Expiry |
|------|------------------|--------------|
| **Active Recordings** | Unlimited | - |
| **Archived Recordings** | 90 days | Moved to Glacier |
| **Deleted Recordings** | 30 days (soft delete) | Permanent deletion |
| **Transcriptions** | Unlimited | - |

---

## Related Endpoints

- [Get Call Recordings](/api-reference/call-management/get-call-recordings) - List all recordings
- [Get Conversation Logs](/api-reference/call-management/get-conversation-logs) - View transcripts
- [WebSocket Events](/api-reference/websockets/real-time-events) - Real-time notifications

---

## Best Practices

1. **Respond quickly** - Return 200 OK within 5 seconds
2. **Process async** - Don't block webhook response
3. **Validate signatures** - Always verify Plivo signature
4. **Handle duplicates** - Use idempotency keys
5. **Monitor failures** - Alert on download/upload errors
6. **Store metadata** - Keep call context with recording
7. **Implement retries** - Exponential backoff for failures
8. **Clean up temp files** - Delete after upload completes
9. **Compress before upload** - Save bandwidth/storage costs
10. **Enable versioning** - S3 versioning for data safety

---

##  Security Considerations

- **Encrypt at rest** - Use S3 server-side encryption
- **Presigned URLs** - Time-limited access to recordings
- **Access logs** - Track who accessed recordings
- **PCI/HIPAA compliance** - Follow regulatory requirements
- **Data masking** - Redact sensitive info (SSN, credit cards)
- **Role-based access** - Restrict recording access by role

---

**Recording processing is async and may take 30s-2min depending on duration.** ‚è±Ô∏è
